{"version":3,"file":"static/chunks/14173.b6455b2692464ff2.js","mappings":"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","sources":["webpack://_N_E/./src/lib/utils/json2go.js"],"sourcesContent":["/*\n\tJSON-to-Go\n\tby Matt Holt\n\n\thttps://github.com/mholt/json-to-go\n\n\tA simple utility to translate JSON into a Go type definition.\n*/\n\nfunction jsonToGo(json, typename, flatten = true, example = false, allOmitempty = false) {\n  let data;\n  let scope;\n  let go = \"\";\n  let tabs = 0;\n\n  const seen = {};\n  const stack = [];\n  let accumulator = \"\";\n  const innerTabs = 0;\n  let parent = \"\";\n\n  try {\n    data = JSON.parse(json.replace(/(:\\s*\\[?\\s*-?\\d*)\\.0/g, \"$1.1\")); // hack that forces floats to stay as floats\n    scope = data;\n  } catch (e) {\n    return {\n      go: \"\",\n      error: e.message,\n    };\n  }\n\n  typename = format(typename || \"Root\");\n  append(`type ${typename} `);\n\n  parseScope(scope);\n\n  return {\n    go: flatten ? (go += accumulator) : go,\n  };\n\n  function parseScope(scope, depth = 0) {\n    if (typeof scope === \"object\" && scope !== null) {\n      if (Array.isArray(scope)) {\n        let sliceType;\n        const scopeLength = scope.length;\n\n        for (let i = 0; i < scopeLength; i++) {\n          const thisType = goType(scope[i]);\n          if (!sliceType) sliceType = thisType;\n          else if (sliceType != thisType) {\n            sliceType = mostSpecificPossibleGoType(thisType, sliceType);\n            if (sliceType == \"any\") break;\n          }\n        }\n\n        const slice = flatten && [\"struct\", \"slice\"].includes(sliceType) ? `[]${parent}` : \"[]\";\n\n        if (flatten && depth >= 2) appender(slice);\n        else append(slice);\n        if (sliceType == \"struct\") {\n          const allFields = {};\n\n          // for each field counts how many times appears\n          for (let i = 0; i < scopeLength; i++) {\n            const keys = Object.keys(scope[i]);\n            for (const k in keys) {\n              let keyname = keys[k];\n              if (!(keyname in allFields)) {\n                allFields[keyname] = {\n                  value: scope[i][keyname],\n                  count: 0,\n                };\n              } else {\n                const existingValue = allFields[keyname].value;\n                const currentValue = scope[i][keyname];\n\n                if (compareObjects(existingValue, currentValue)) {\n                  const comparisonResult = compareObjectKeys(\n                    Object.keys(currentValue),\n                    Object.keys(existingValue)\n                  );\n                  if (!comparisonResult) {\n                    keyname = `${keyname}_${uuidv4()}`;\n                    allFields[keyname] = {\n                      value: currentValue,\n                      count: 0,\n                    };\n                  }\n                }\n              }\n              allFields[keyname].count++;\n            }\n          }\n\n          // create a common struct with all fields found in the current array\n          // omitempty dict indicates if a field is optional\n          const keys = Object.keys(allFields),\n            struct = {},\n            omitempty = {};\n          for (const k in keys) {\n            const keyname = keys[k],\n              elem = allFields[keyname];\n\n            struct[keyname] = elem.value;\n            omitempty[keyname] = elem.count != scopeLength;\n          }\n          parseStruct(depth + 1, innerTabs, struct, omitempty); // finally parse the struct !!\n        } else if (sliceType == \"slice\") {\n          parseScope(scope[0], depth);\n        } else {\n          if (flatten && depth >= 2) {\n            appender(sliceType || \"any\");\n          } else {\n            append(sliceType || \"any\");\n          }\n        }\n      } else {\n        if (flatten) {\n          if (depth >= 2) {\n            appender(parent);\n          } else {\n            append(parent);\n          }\n        }\n        parseStruct(depth + 1, innerTabs, scope);\n      }\n    } else {\n      if (flatten && depth >= 2) {\n        appender(goType(scope));\n      } else {\n        append(goType(scope));\n      }\n    }\n  }\n\n  function parseStruct(depth, innerTabs, scope, omitempty) {\n    if (flatten) {\n      stack.push(depth >= 2 ? \"\\n\" : \"\");\n    }\n\n    const seenTypeNames = [];\n\n    if (flatten && depth >= 2) {\n      const parentType = `type ${parent}`;\n      const scopeKeys = formatScopeKeys(Object.keys(scope));\n\n      // this can only handle two duplicate items\n      // future improvement will handle the case where there could\n      // three or more duplicate keys with different values\n      if (parent in seen && compareObjectKeys(scopeKeys, seen[parent])) {\n        stack.pop();\n        return;\n      }\n      seen[parent] = scopeKeys;\n\n      appender(`${parentType} struct {\\n`);\n      ++innerTabs;\n      const keys = Object.keys(scope);\n      for (const i in keys) {\n        const keyname = getOriginalName(keys[i]);\n        indenter(innerTabs);\n        const typename = uniqueTypeName(format(keyname), seenTypeNames);\n        seenTypeNames.push(typename);\n\n        appender(typename + \" \");\n        parent = typename;\n        parseScope(scope[keys[i]], depth);\n        appender(' `json:\"' + keyname);\n        if (allOmitempty || (omitempty && omitempty[keys[i]] === true)) {\n          appender(\",omitempty\");\n        }\n        appender('\"`\\n');\n      }\n      indenter(--innerTabs);\n      appender(\"}\");\n    } else {\n      append(\"struct {\\n\");\n      ++tabs;\n      const keys = Object.keys(scope);\n      for (const i in keys) {\n        const keyname = getOriginalName(keys[i]);\n        indent(tabs);\n        const typename = uniqueTypeName(format(keyname), seenTypeNames);\n        seenTypeNames.push(typename);\n        append(typename + \" \");\n        parent = typename;\n        parseScope(scope[keys[i]], depth);\n        append(' `json:\"' + keyname);\n        if (allOmitempty || (omitempty && omitempty[keys[i]] === true)) {\n          append(\",omitempty\");\n        }\n        if (example && scope[keys[i]] !== \"\" && typeof scope[keys[i]] !== \"object\") {\n          append('\" example:\"' + scope[keys[i]]);\n        }\n        append('\"`\\n');\n      }\n      indent(--tabs);\n      append(\"}\");\n    }\n    if (flatten) accumulator += stack.pop();\n  }\n\n  function indent(tabs) {\n    for (let i = 0; i < tabs; i++) go += \"\\t\";\n  }\n\n  function append(str) {\n    go += str;\n  }\n\n  function indenter(tabs) {\n    for (let i = 0; i < tabs; i++) stack[stack.length - 1] += \"\\t\";\n  }\n\n  function appender(str) {\n    stack[stack.length - 1] += str;\n  }\n\n  // Generate a unique name to avoid duplicate struct field names.\n  // This function appends a number at the end of the field name.\n  function uniqueTypeName(name, seen) {\n    if (seen.indexOf(name) === -1) {\n      return name;\n    }\n\n    let i = 0;\n    while (true) {\n      const newName = name + i.toString();\n      if (seen.indexOf(newName) === -1) {\n        return newName;\n      }\n\n      i++;\n    }\n  }\n\n  // Sanitizes and formats a string to make an appropriate identifier in Go\n  function format(str) {\n    str = formatNumber(str);\n\n    const sanitized = toProperCase(str).replace(/[^a-z0-9]/gi, \"\");\n    if (!sanitized) {\n      return \"NAMING_FAILED\";\n    }\n\n    // After sanitizing the remaining characters can start with a number.\n    // Run the sanitized string again trough formatNumber to make sure the identifier is Num[0-9] or Zero_... instead of 1.\n    return formatNumber(sanitized);\n  }\n\n  // Adds a prefix to a number to make an appropriate identifier in Go\n  function formatNumber(str) {\n    if (!str) return \"\";\n    else if (str.match(/^\\d+$/)) str = \"Num\" + str;\n    else if (str.charAt(0).match(/\\d/)) {\n      const numbers = {\n        0: \"Zero_\",\n        1: \"One_\",\n        2: \"Two_\",\n        3: \"Three_\",\n        4: \"Four_\",\n        5: \"Five_\",\n        6: \"Six_\",\n        7: \"Seven_\",\n        8: \"Eight_\",\n        9: \"Nine_\",\n      };\n      str = numbers[str.charAt(0)] + str.substr(1);\n    }\n\n    return str;\n  }\n\n  // Determines the most appropriate Go type\n  function goType(val) {\n    if (val === null) return \"any\";\n\n    switch (typeof val) {\n      case \"string\":\n        if (/\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d+)?(\\+\\d\\d:\\d\\d|Z)/.test(val)) return \"time.Time\";\n        else return \"string\";\n      case \"number\":\n        if (val % 1 === 0) {\n          if (val > -2147483648 && val < 2147483647) return \"int\";\n          else return \"int64\";\n        } else return \"float64\";\n      case \"boolean\":\n        return \"bool\";\n      case \"object\":\n        if (Array.isArray(val)) return \"slice\";\n        return \"struct\";\n      default:\n        return \"any\";\n    }\n  }\n\n  // Given two types, returns the more specific of the two\n  function mostSpecificPossibleGoType(typ1, typ2) {\n    if (typ1.substr(0, 5) == \"float\" && typ2.substr(0, 3) == \"int\") return typ1;\n    else if (typ1.substr(0, 3) == \"int\" && typ2.substr(0, 5) == \"float\") return typ2;\n    else return \"any\";\n  }\n\n  // Proper cases a string according to Go conventions\n  function toProperCase(str) {\n    // ensure that the SCREAMING_SNAKE_CASE is converted to snake_case\n    if (str.match(/^[_A-Z0-9]+$/)) {\n      str = str.toLowerCase();\n    }\n\n    // https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810\n    const commonInitialisms = [\n      \"ACL\",\n      \"API\",\n      \"ASCII\",\n      \"CPU\",\n      \"CSS\",\n      \"DNS\",\n      \"EOF\",\n      \"GUID\",\n      \"HTML\",\n      \"HTTP\",\n      \"HTTPS\",\n      \"ID\",\n      \"IP\",\n      \"JSON\",\n      \"LHS\",\n      \"QPS\",\n      \"RAM\",\n      \"RHS\",\n      \"RPC\",\n      \"SLA\",\n      \"SMTP\",\n      \"SQL\",\n      \"SSH\",\n      \"TCP\",\n      \"TLS\",\n      \"TTL\",\n      \"UDP\",\n      \"UI\",\n      \"UID\",\n      \"UUID\",\n      \"URI\",\n      \"URL\",\n      \"UTF8\",\n      \"VM\",\n      \"XML\",\n      \"XMPP\",\n      \"XSRF\",\n      \"XSS\",\n    ];\n\n    return str\n      .replace(/(^|[^a-zA-Z])([a-z]+)/g, function (unused, sep, frag) {\n        if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0) return sep + frag.toUpperCase();\n        else return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();\n      })\n      .replace(/([A-Z])([a-z]+)/g, function (unused, sep, frag) {\n        if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)\n          return (sep + frag).toUpperCase();\n        else return sep + frag;\n      });\n  }\n\n  function uuidv4() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n      var r = (Math.random() * 16) | 0,\n        v = c == \"x\" ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n\n  function getOriginalName(unique) {\n    const reLiteralUUID =\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    const uuidLength = 36;\n\n    if (unique.length >= uuidLength) {\n      const tail = unique.substr(-uuidLength);\n      if (reLiteralUUID.test(tail)) {\n        return unique.slice(0, -1 * (uuidLength + 1));\n      }\n    }\n    return unique;\n  }\n\n  function compareObjects(objectA, objectB) {\n    const object = \"[object Object]\";\n    return (\n      Object.prototype.toString.call(objectA) === object &&\n      Object.prototype.toString.call(objectB) === object\n    );\n  }\n\n  function compareObjectKeys(itemAKeys, itemBKeys) {\n    const lengthA = itemAKeys.length;\n    const lengthB = itemBKeys.length;\n\n    // nothing to compare, probably identical\n    if (lengthA == 0 && lengthB == 0) return true;\n\n    // duh\n    if (lengthA != lengthB) return false;\n\n    for (const item of itemAKeys) {\n      if (!itemBKeys.includes(item)) return false;\n    }\n    return true;\n  }\n\n  function formatScopeKeys(keys) {\n    for (const i in keys) {\n      keys[i] = format(keys[i]);\n    }\n    return keys;\n  }\n}\n\nif (typeof module != \"undefined\") {\n  module.exports = jsonToGo;\n}\n"],"names":["module","exports","jsonToGo","json","typename","flatten","example","allOmitempty","scope","go","tabs","seen","stack","accumulator","parent","JSON","parse","data","replace","e","error","message","format","parseScope","depth","typ1","Array","isArray","sliceType","scopeLength","length","i","thisType","goType","typ2","mostSpecificPossibleGoType","substr","slice","includes","appender","allFields","keys","Object","k","keyname","existingValue","value","currentValue","compareObjects","objectA","objectB","object","prototype","toString","call","compareObjectKeys","uuidv4","c","r","random","v","count","struct","omitempty","elem","parseStruct","innerTabs","str","push","seenTypeNames","parentType","scopeKeys","formatScopeKeys","pop","getOriginalName","indenter","uniqueTypeName","indent","name","indexOf","newName","sanitized","toProperCase","formatNumber","match","toLowerCase","commonInitialisms","unused","sep","frag","toUpperCase","charAt","numbers","val","test","unique","uuidLength","tail","itemAKeys","itemBKeys","lengthA","lengthB","item"],"sourceRoot":"","ignoreList":[]}