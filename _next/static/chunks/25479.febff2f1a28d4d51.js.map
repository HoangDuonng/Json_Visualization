{"version":3,"file":"static/chunks/25479.febff2f1a28d4d51.js","mappings":"iFAAA,MAAY,EAAQ,KAAQ,CAE5B,WASA,YACA,eACA,WACA,WACA,UAHA,wCAIA,cACA,UADA,6FAEA,qDACA,0GAMA,IAJA,SACA,KACA,IAEA,aAGA,YACA,YACA,YACA,YAGA,aACA,mBACA,aACA,YACA,YACA,YAGA,MACA,0BACA,0BACA,0BACA,0BAIA,yBACA,mCAKA,eACA,KACA,QACA,OACA,sBACA,CAAO,EAEP,KACA,CAGA,YAAoB,IAAY,IAChC,YAKA,YACA,YACA,YACA,YAEA,WAEA,GADA,WACA,EACA,YACA,0EAMA,wCAEA,QACA,OACA,MACA,CAAK,CACL,CAEA,MACA,qEAGA,QACA,EA9FA,wBACA,2BACA,qOCIO,IAAMA,EAAe,MAC1BC,IAGA,IAAMC,EADSC,IAAU,IAAIC,WAAW,MAAMC,CAAAA,EAAAA,EAAAA,EAAAA,CAAiBA,CAACJ,KACnCK,IAAI,CAAC,GAA0B,SAAfC,CADrBJ,CAC2BK,IAAI,SACvD,EACSC,EAAAA,MAAW,CAACP,EAAcQ,EADhB,EACoB,EAEhC,IACT,EAAE,EAE+B,MAAO,MACtCT,CAAI,UACJU,CAAQ,CAIT,IACC,IAAMC,EAAST,IAAU,IAAIC,WAAW,MAAMC,CAAAA,EAAAA,EAAAA,EAAAA,CAAiBA,CAACJ,KAE1DC,EAAgBO,EAAAA,MAAW,CAC/BI,EAAAA,GAAUA,CAACC,CAHWX,OAGH,CACnBY,KAAKC,SAAS,CACZC,CAAAA,EAAAA,EAAAA,EAAAA,CAAMA,CAAC,CACLC,KAAMP,EACNQ,UAAU,CACZ,KAMJ,OAFAP,EAAOQ,MAAM,CAAC,CAAC,EAAG,EAAGlB,GAEd,IAAImB,KAAK,CAACC,IAAUV,GAAQ,CAAE,CAAEW,KAAMV,EAAAA,GAAUA,CAACW,GAAG,EAC7D,EAAE,EAE+B,MAAOvB,IACtC,IAAMU,EAAW,MAAMX,EAAaC,GACpC,GAAIU,GAAUc,UAAYZ,EAAAA,GAAUA,CAACC,QAAQ,CAC3C,CAD6C,EACzC,CACF,IAAMY,EAAcX,KAAKY,KAAK,CAAChB,EAASO,IAAI,EAC5C,GAAI,CAAE,aAAaQ,CAAAA,CAAU,CAAI,CAE/B,GACE,SAAUA,GACVA,EAAYH,IAAI,GAAKK,EAAAA,GAAiBA,CAACd,QAAQ,CAE/C,CADA,MACOH,EAASO,IAAI,OAEhB,MAAU,SAClB,CACA,MAAOW,CAAAA,EAAAA,EAAAA,EAAAA,CAAMA,CAACH,EAChB,CAAE,MAAOI,EAAY,CAEnB,MADAC,QAAQD,KAAK,CAACA,GACR,MAAU,SAClB,CAEF,MAAM,MAAU,UAClB,EAAE,iBCtEF,iBAAoC,CACpC,iBAAoC,sBCEpC,sBAgBC,YACD,kBAqBA,MAnBA,WAGA,QAFA,iBAEA,IAAe,OAAU,IASzB,IADA,KADA,KADA,KADA,KADA,KADA,KADA,KADA,MACA,yBACA,yBACA,yBACA,yBACA,yBACA,yBACA,yBACA,wBACA,OAGA,+CACA,IAIA,OAA8B,IAAN,EAwBxB,IAxB8B,KAwB9B,KACA,8BAA0C,IAAM,CAQhD,EADA,GADA,GADA,GADA,GADA,GADA,IADA,6BACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,oBAEA,sCACA,WACA,CAyBA,UACA,OA9DA,YACA,kCAA+D,EAAM,QAErE,IADA,kBACA,IAAgB,IAAM,CACtB,qCACA,qCAGA,OADA,4CACA,IACA,EAsDA,MApDA,YACA,4BACA,8BAA0C,IAAM,CAIhD,EADA,GADA,GADA,8BACA,uBACA,uBACA,oBAEA,sCACA,WACA,EA2CA,MAzBA,YACA,gCAA8C,IAAM,CACpD,sBACA,IACA,qBACI,OAEJ,GADA,oCACA,wBACI,mBACJ,cAAoB,yBAIpB,EADA,GADA,IADA,mCACA,8BACA,kCACA,yBAIA,EADA,IADA,qCACA,8BACA,wBAGA,WACA,CAKA,CAAC,CAzGD,6BAEA,KAWA,IAAoB,aCjBpB,UAEA,YACA,gBACA,WAOA,QAJA,KACA,KACA,KAEA,IAAkB,WAAiB,KACnC,WAEA,KACA,EACA,0BAEA,UAGA,KACA,+BAEA,4FAGA,CAEA,OACA,UACA,MACA,CACA,mBCjCA,MAAa,EAAQ,KAAQ,EAC7B,EAAY,EAAQ,KAAQ,CADR,CAGpB,UAFmB,SAWnB,GACA,IAEA,EAFA,IACA,EADA,EAIA,QAAc,WAAmB,IACjC,oBACA,MAGA,wBAWA,QATA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QAEc,WAAmB,KACjC,WACA,SACA,SACA,WACA,GACA,gBACA,gBACA,gBACA,gBACA,CAEA,OACA,YACA,YACA,YACA,YAEA,YACA,YACA,YACA,YAEA,YAAoB,KACpB,EAD6B,IAC7B,QAGA,qBACA,UAEA,QACA,YACA,YACA,YACA,YAGA,QACA,EA/DA,wBACA,2BACA,uCCVA,UAEA,cAIA,GAHA,YACA,YAEA,qDACA,4IAGA,gBACA,sGAQA,QAFA,EAFA,iBADA,qBAEA,IAGA,IAAkB,WAAoB,KACtC,wBACA,+DAGA,SACA,CAEA,SAEA,YAAkB,WAAoB,KACtC,wBACA,8DAGA,SACA,CAEA,OACA,YACA,MACA,CACA,aC/BA,0BACA,SACA,WAEA,kBAEA,UACA,gBACA,KAQA,IANA,YACA,OACA,IACA,GAGA,QACA,YAGA,QACA","sources":["webpack://_N_E/./node_modules/png-chunks-extract/index.js","webpack://_N_E/./src/jsondraw/packages/jsondraw/data/image.ts","webpack://_N_E/./node_modules/png-chunk-text/index.js","webpack://_N_E/./node_modules/crc-32/crc32.js","webpack://_N_E/./node_modules/png-chunk-text/decode.js","webpack://_N_E/./node_modules/png-chunks-encode/index.js","webpack://_N_E/./node_modules/png-chunk-text/encode.js","webpack://_N_E/./node_modules/sliced/index.js"],"sourcesContent":["var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n","import tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport decodePng from \"png-chunks-extract\";\n\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"@jsondraw/common\";\n\nimport { blobToArrayBuffer } from \"./blob\";\nimport { encode, decode } from \"./encode\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nexport const getTEXtChunk = async (\n  blob: Blob,\n): Promise<{ keyword: string; text: string } | null> => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\n\nexport const encodePngMetadata = async ({\n  blob,\n  metadata,\n}: {\n  blob: Blob;\n  metadata: string;\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n\n  const metadataChunk = tEXt.encode(\n    MIME_TYPES.jsondraw,\n    JSON.stringify(\n      encode({\n        text: metadata,\n        compress: true,\n      }),\n    ),\n  );\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n\n  return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });\n};\n\nexport const decodePngMetadata = async (blob: Blob) => {\n  const metadata = await getTEXtChunk(blob);\n  if (metadata?.keyword === MIME_TYPES.jsondraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\n          \"type\" in encodedData &&\n          encodedData.type === EXPORT_DATA_TYPES.jsondraw\n        ) {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return decode(encodedData);\n    } catch (error: any) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n","exports.encode = require('./encode')\nexports.decode = require('./decode')\n","/* crc32.js (C) 2014-2015 SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\nvar CRC32;\n(function (factory) {\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t  factory(CRC32 = {});\n\t\t}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n}(function(CRC32) {\nCRC32.version = '0.3.0';\n/* see perf/crc32table.js */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar table = signed_crc_table();\n/* charCodeAt is the best approach for binary strings */\nvar use_buffer = typeof Buffer !== 'undefined';\nfunction crc32_bstr(bstr) {\n\tif(bstr.length > 32768) if(use_buffer) return crc32_buf_8(new Buffer(bstr));\n\tvar crc = -1, L = bstr.length - 1;\n\tfor(var i = 0; i < L;) {\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t}\n\tif(i === L) crc = (crc >>> 8) ^ table[(crc ^ bstr.charCodeAt(i)) & 0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf(buf) {\n\tif(buf.length > 10000) return crc32_buf_8(buf);\n\tfor(var crc = -1, i = 0, L=buf.length-3; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+3) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf_8(buf) {\n\tfor(var crc = -1, i = 0, L=buf.length-7; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+7) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\n/* much much faster to intertwine utf8 and crc */\nfunction crc32_str(str) {\n\tfor(var crc = -1, i = 0, L=str.length, c, d; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ c) & 0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (192|((c>>6)&31))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++) & 1023;\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (240|((c>>8)&7))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>2)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((d>>6)&15)|(c&3))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(d&63))) & 0xFF];\n\t\t} else {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (224|((c>>12)&15))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>6)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t}\n\t}\n\treturn crc ^ -1;\n}\nCRC32.table = table;\nCRC32.bstr = crc32_bstr;\nCRC32.buf = crc32_buf;\nCRC32.str = crc32_str;\n}));\n","module.exports = decode\n\nfunction decode (data) {\n  if (data.data && data.name) {\n    data = data.data\n  }\n\n  var naming = true\n  var text = ''\n  var name = ''\n\n  for (var i = 0; i < data.length; i++) {\n    var code = data[i]\n\n    if (naming) {\n      if (code) {\n        name += String.fromCharCode(code)\n      } else {\n        naming = false\n      }\n    } else {\n      if (code) {\n        text += String.fromCharCode(code)\n      } else {\n        throw new Error('Invalid NULL character found. 0x00 character is not permitted in tEXt content')\n      }\n    }\n  }\n\n  return {\n    keyword: name,\n    text: text\n  }\n}\n","var sliced = require('sliced')\nvar crc32 = require('crc-32')\n\nmodule.exports = encodeChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction encodeChunks (chunks) {\n  var totalSize = 8\n  var idx = totalSize\n  var i\n\n  for (i = 0; i < chunks.length; i++) {\n    totalSize += chunks[i].data.length\n    totalSize += 12\n  }\n\n  var output = new Uint8Array(totalSize)\n\n  output[0] = 0x89\n  output[1] = 0x50\n  output[2] = 0x4E\n  output[3] = 0x47\n  output[4] = 0x0D\n  output[5] = 0x0A\n  output[6] = 0x1A\n  output[7] = 0x0A\n\n  for (i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i]\n    var name = chunk.name\n    var data = chunk.data\n    var size = data.length\n    var nameChars = [\n      name.charCodeAt(0),\n      name.charCodeAt(1),\n      name.charCodeAt(2),\n      name.charCodeAt(3)\n    ]\n\n    uint32[0] = size\n    output[idx++] = uint8[3]\n    output[idx++] = uint8[2]\n    output[idx++] = uint8[1]\n    output[idx++] = uint8[0]\n\n    output[idx++] = nameChars[0]\n    output[idx++] = nameChars[1]\n    output[idx++] = nameChars[2]\n    output[idx++] = nameChars[3]\n\n    for (var j = 0; j < size;) {\n      output[idx++] = data[j++]\n    }\n\n    var crcCheck = nameChars.concat(sliced(data))\n    var crc = crc32.buf(crcCheck)\n\n    int32[0] = crc\n    output[idx++] = uint8[3]\n    output[idx++] = uint8[2]\n    output[idx++] = uint8[1]\n    output[idx++] = uint8[0]\n  }\n\n  return output\n}\n","module.exports = encode\n\nfunction encode (keyword, content) {\n  keyword = String(keyword)\n  content = String(content)\n\n  if (!/^[\\x00-\\xFF]+$/.test(keyword) || !/^[\\x00-\\xFF]+$/.test(content)) {\n    throw new Error('Only Latin-1 characters are permitted in PNG tEXt chunks. You might want to consider base64 encoding and/or zEXt compression')\n  }\n\n  if (keyword.length >= 80) {\n    throw new Error('Keyword \"' + keyword + '\" is longer than the 79-character limit imposed by the PNG specification')\n  }\n\n  var totalSize = keyword.length + content.length + 1\n  var output = new Uint8Array(totalSize)\n  var idx = 0\n  var code\n\n  for (var i = 0; i < keyword.length; i++) {\n    if (!(code = keyword.charCodeAt(i))) {\n      throw new Error('0x00 character is not permitted in tEXt keywords')\n    }\n\n    output[idx++] = code\n  }\n\n  output[idx++] = 0\n\n  for (var j = 0; j < content.length; j++) {\n    if (!(code = content.charCodeAt(j))) {\n      throw new Error('0x00 character is not permitted in tEXt content')\n    }\n\n    output[idx++] = code\n  }\n\n  return {\n    name: 'tEXt',\n    data: output\n  }\n}\n","\n/**\n * An Array.prototype.slice.call(arguments) alternative\n *\n * @param {Object} args something with a length\n * @param {Number} slice\n * @param {Number} sliceEnd\n * @api public\n */\n\nmodule.exports = function (args, slice, sliceEnd) {\n  var ret = [];\n  var len = args.length;\n\n  if (0 === len) return ret;\n\n  var start = slice < 0\n    ? Math.max(0, slice + len)\n    : slice || 0;\n\n  if (sliceEnd !== undefined) {\n    len = sliceEnd < 0\n      ? sliceEnd + len\n      : sliceEnd\n  }\n\n  while (len-- > start) {\n    ret[len - start] = args[len];\n  }\n\n  return ret;\n}\n\n"],"names":["getTEXtChunk","blob","metadataChunk","decodePng","Uint8Array","blobToArrayBuffer","find","chunk","name","tEXt","data","metadata","chunks","MIME_TYPES","jsondraw","JSON","stringify","encode","text","compress","splice","Blob","encodePng","type","png","keyword","encodedData","parse","EXPORT_DATA_TYPES","decode","error","console"],"sourceRoot":"","ignoreList":[0,2,3,4,5,6,7]}